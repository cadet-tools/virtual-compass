<!doctype html>
<html lang="lv">
<head>
  <meta charset="UTF-8">
  <title>Mērogs un attālumi — Virtuālais kompass</title>
  <meta name="viewport" content="width=device-width, initial-scale=1">

  <style>
    /* width */
  ::-webkit-scrollbar {
      width: 5px;
  }
  
  /* Track */
  ::-webkit-scrollbar-track {
      box-shadow: inset 0 0 5px grey; 
      border-radius: 10px;
  }
   
  /* Handle */
  ::-webkit-scrollbar-thumb {
      background: rgba(255, 0, 0, 0.6); 
      border-radius: 10px;
  }
    body{
      margin: 0;
      font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
      background-image: url(./img/topografija.jpg);
      background-repeat: no-repeat;
      background-size: cover;
      background-position: center;
      min-height: 100vh;
}
    

    /* 3 konteineru izkārtojums */
   .parent {
  display: grid;
  grid-template-columns: repeat(2, 1fr);
  grid-template-rows: repeat(3, auto);
  gap: 8px;
  padding: 12px;

  /* JAUNAIS */
  max-width: 90%;      /* vai citu vērtību, kas patīk */
  margin: 40px auto;      /* atstāj malas un iecentrē */
}
    .div1,
    .div2,
    .div3{
      background:#f9f1e6;
      border-radius:12px;
      border:1px solid #444;
      box-shadow:0 4px 10px rgba(0,0,0,.1);
      padding:8px;
      position:relative;
      min-height:120px;
    }
    .div1{ grid-column: span 2 / span 2; }
    .div2{
      grid-row: span 2 / span 2;
      grid-row-start: 2;
    }
    .div3{
      grid-row: span 2 / span 2;
      grid-row-start: 2;
    }

    /* ---- MĒROGA WIDGETA STILS ---- */

    #myScaleWidget{
      position:relative;
      width:100%;
      height:100%;
    }

    #scaleMapContainer {
      position: relative;
      width: 100%;
      height: 85vh;
      overflow: hidden;
      background: black;
      border-radius: 7px;
    }

    @media (max-width: 1024px) {
      #scaleMapContainer {
        height: 100vh;
      }
    }

    #mapImage {
      width: 100%;
      height: 100%;
      object-fit: cover;
      filter: brightness(0.9);
    }

    #rulerContainer {
      position: absolute;
      top: 15%;
      left: 50%;
      transform: translateX(-50%);
      width: clamp(300px, 80vw, 800px);
      height: 60px;
      z-index: 5;
    }

    #ruler {
      position: relative;
      width: 100%;
      height: 70px;
      background: rgba(0, 0, 0, 0.7);
      margin-bottom: 10px;
    }

    .tick {
      position: absolute;
      bottom: 0;
      background: red;
    }
    .tick.cm {
      width: 2px;
      height: 20px;
      top: 0;
    }
    .tick.mm {
      width: 1px;
      height: 10px;
      top: 0;
    }
    .tick-label {
      position: absolute;
      white-space: nowrap;
      top: 30px;
      color: red;
      font-size: 12px;
      transform: translateX(-50%);
    }

    .marker {
      position: absolute;
      width: 30px;
      height: 30px;
      border-radius: 50%;
      background: transparent;
      border: 5px solid red;
      cursor: pointer;
      z-index: 10;
      box-sizing: border-box;
      top: -25px;
    }

    /* Bultiņu animācija */
    @keyframes arrowPulseLeft {
      0%, 100% { transform: translateX(0) translateY(-50%); }
      50% { transform: translateX(-5px) translateY(-50%); }
    }
    @keyframes arrowPulseRight {
      0%, 100% { transform: translateX(0) translateY(-50%); }
      50% { transform: translateX(5px) translateY(-50%); }
    }

    #markerDraggable::before,
    #markerDraggable::after {
      position: absolute;
      top: 50%;
      transform: translateY(-50%);
      font-size: 30px;
      color: red;
    }
    #markerDraggable::before {
      content: "❮";
      left: -28px;
      animation: arrowPulseLeft 1s infinite;
    }
    #markerDraggable::after {
      content: "❯";
      right: -28px;
      animation: arrowPulseRight 1s infinite;
    }

    #infoContainer {
      position: absolute;
      bottom: 1%;
      left: 50%;
      transform: translateX(-50%);
      width: 90%;
      background: rgba(0, 0, 0, 0.8);
      padding: 8px 12px;
      border-radius: 7px;
      font-size: 14px;
      color: white;
      z-index: 2;
      display: flex;
      justify-content: space-between;
      align-items: center;
      gap:10px;
    }
    #explanation {
      text-align: left;
      font-size:13px;
    }
    #controls{
      min-width:120px;
      margin-right: 50px;
    }
    #controls input,
    #controls select {
      padding: 5px;
      margin: 2px;
      font-size: 14px;
      border: 1px solid #783200;
      background: rgba(0, 0, 0, 0.8);
      width: 100%;
      text-align: center;
      color: white;
      margin-top: 5px;
    }

    #MapOverlay {
      position: absolute;
      bottom: 4%;
      left: 50%;
      transform: translateX(-50%);
      width: 95%;
      height: 10%;
      background-color: rgba(255, 0, 0, 1);
      color: white;
      display: none;
      justify-content: center;
      align-items: center;
      border-radius: 5px;
      font-size: 16px;
      z-index: 100;
    }

    #rotateOverlay {
      display: none;
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(0, 0, 0, 0.8);
      color: white;
      z-index: 300;
      justify-content: center;
      align-items: center;
      text-align: center;
      padding: 20px;
      font-size: 18px;
      border-radius: inherit;
    }
  </style>
</head>
<body>

  <div class="parent">
    <!-- 1. KONTEINERS: interaktīvais lineāls -->
    <div class="div1">
      <div id="myScaleWidget">
        <div id="scaleMapContainer">
          <!-- Paziņojums par orientāciju -->
          <div id="rotateOverlay">
            Lūdzu, pagrieziet ierīci horizontālā orientācijā, lai izmantotu šo interaktīvo materiālu!
          </div>

          <div id="MapOverlay">Materiāls nav pieejams testa izpildes laikā!</div>

          <!-- Karte (vari pārlikt uz savu img/ mapi) -->
          <img id="mapImage"
               src="./img/karte virtual kompass dark.jpg"
               alt="Karte">

          <div id="rulerContainer">
            <div id="ruler"></div>
          </div>

          <div id="infoContainer">
            <div id="explanation" style="display:none;"></div>
            <div id="controls">
              <input type="text" id="scale-maps" placeholder="1:25000" value="1:25000">
              <select id="unit">
                <option value="cm" selected>cm</option>
                <option value="mm">mm</option>
              </select>
            </div>
          </div>
        </div>
      </div>
    </div>

    <!-- 2. un 3. konteineris – pagaidām tukši vietturi -->
    <div class="div2">
      2. konteiners (šeit vēlāk ieliksi nākamo interaktīvo materiālu)
    </div>
    <div class="div3">
      3. konteiners (šeit vēlāk ieliksi nākamo interaktīvo materiālu)
    </div>
  </div>

  <script>
    // gaidām, kamēr viss HTML ielādējas
    document.addEventListener('DOMContentLoaded', function () {
      let currentCmValue = 5; // sākotnējais attālums cm
      let isDragging = false;

      const rulerContainer = document.getElementById('rulerContainer');
      const ruler = document.getElementById('ruler');

      if (!rulerContainer || !ruler) return; // drošības pārbaude

      const markerStart = document.createElement('div');
      markerStart.id = 'markerStart';
      markerStart.classList.add('marker');
      rulerContainer.appendChild(markerStart);

      const markerDraggable = document.createElement('div');
      markerDraggable.id = 'markerDraggable';
      markerDraggable.classList.add('marker');
      rulerContainer.appendChild(markerDraggable);

      function createRulerTicks() {
        const rulerWidth = ruler.clientWidth;
        const totalMm = 20 * 10; // 20 cm = 200 mm
        const effectiveWidth = rulerWidth * 0.98;
        const leftMargin = rulerWidth * 0.01;

        ruler.innerHTML = "";

        for (let i = 0; i <= totalMm; i++) {
          const tick = document.createElement('div');
          const pos = leftMargin + i * effectiveWidth / totalMm;

          if (i % 10 === 0) {
            tick.classList.add('tick', 'cm');
            tick.style.left = (pos - 1) + 'px';

            const label = document.createElement('div');
            label.classList.add('tick-label');
            label.style.left = pos + 'px';

            if (i === 0) {
              label.textContent = "0";
            } else {
              label.textContent = (i / 10).toFixed(0);
              if (i === totalMm) {
                label.style.transform = "translateX(-90%)";
              }
            }
            ruler.appendChild(label);
          } else {
            tick.classList.add('tick', 'mm');
            tick.style.left = pos + 'px';
          }
          ruler.appendChild(tick);
        }
      }

      function updateMarkerStart() {
        const rulerWidth = ruler.clientWidth;
        const leftMargin = rulerWidth * 0.01;
        markerStart.style.left = (leftMargin - 15) + 'px';
      }

      function setMarkerDraggablePosition(cmValue) {
        const containerRect = rulerContainer.getBoundingClientRect();
        const fullWidth = containerRect.width;
        const leftMarginPx = fullWidth * 0.01;
        const effectiveWidthPx = fullWidth * 0.98;
        const x = leftMarginPx + (cmValue / 20) * effectiveWidthPx;
        markerDraggable.style.left = (x - 15) + 'px';
        calculateDistanceDynamic(cmValue);
      }

      function calculateDistanceDynamic(measuredCm) {
        const explanationDiv = document.getElementById("explanation");
        const scaleInputEl = document.getElementById("scale-maps");
        const unitEl = document.getElementById("unit");
        if (!explanationDiv || !scaleInputEl || !unitEl) return;

        const scaleInput = scaleInputEl.value;
        let match = scaleInput.match(/1:(\d+)/);
        if (!match) {
          explanationDiv.style.display = "block";
          explanationDiv.innerHTML = "Lūdzu, ievadiet mērogu formātā 1:XXXXXX";
          return;
        }

        let scaleValue = parseInt(match[1], 10);
        let convertedScale = scaleValue;
        let explanationText = `<strong>Aprēķina skaidrojums:</strong><br>` +
                              `Mērogs: 1:${scaleValue}<br>`;

        const unit = unitEl.value;
        let result;

        if (unit === "cm") {
          convertedScale /= 100;
          explanationText += `Mērogs 1:${scaleValue} nozīmē, ka 1 cm uz kartes atbilst ${scaleValue / 100} m dabā.<br>` +
                             `Noņemot pēdējās divas nulles, iegūstam ${convertedScale} m.<br>`;
          result = Math.round(convertedScale * measuredCm);
          explanationText += `Tātad, ja attālums uz kartes ir ${measuredCm.toFixed(2)} cm, tad reālais attālums būs ${result} m dabā.<br><br>`;
          explanationText += `<strong>Formula:</strong><br>`;
          explanationText += `${convertedScale} m x ${measuredCm.toFixed(2)} cm = <strong>${result} m</strong>`;
        } else if (unit === "mm") {
          convertedScale /= 1000;
          explanationText += `Mērogs 1:${scaleValue} nozīmē, ka 1 mm uz kartes atbilst ${scaleValue / 1000} m dabā.<br>` +
                             `Noņemot pēdējās trīs nulles, iegūstam ${convertedScale} m.<br>`;
          let measuredMm = measuredCm * 10;
          explanationText += `Uz kartes attālums: ${measuredMm.toFixed(0)} mm (t.i., ${measuredCm.toFixed(2)} cm).<br>`;
          result = Math.round(convertedScale * measuredMm);
          explanationText += `Tātad, reālais attālums būs ${result} m dabā.<br><br>`;
          explanationText += `<strong>Formula:</strong><br>`;
          explanationText += `${convertedScale} m x ${measuredMm.toFixed(0)} mm = <strong>${result} m</strong>`;
        }

        explanationDiv.style.display = "block";
        explanationDiv.innerHTML = explanationText;
      }

      function updateAll() {
        createRulerTicks();
        updateMarkerStart();
        setMarkerDraggablePosition(currentCmValue);
      }

      function handleDrag(clientX) {
        const containerRect = rulerContainer.getBoundingClientRect();
        const fullWidth = containerRect.width;
        const leftMarginPx = fullWidth * 0.01;
        const effectiveWidthPx = fullWidth * 0.98;
        let x = clientX - containerRect.left;

        if (x < leftMarginPx) x = leftMarginPx;
        if (x > leftMarginPx + effectiveWidthPx) x = leftMarginPx + effectiveWidthPx;

        markerDraggable.style.left = (x - 15) + 'px';
        let measuredCm = ((x - leftMarginPx) / effectiveWidthPx) * 20;
        currentCmValue = measuredCm;
        calculateDistanceDynamic(measuredCm);
      }

      function checkMobileOrientation() {
        const overlay = document.getElementById('rotateOverlay');
        if (!overlay) return;
        if (window.innerWidth < window.innerHeight) {
          overlay.style.display = 'flex';
        } else {
          overlay.style.display = 'none';
        }
      }

      // Reaģē uz loga izmēru un orientāciju
      window.addEventListener('resize', () => {
        updateAll();
        checkMobileOrientation();
      });
      window.addEventListener('load', checkMobileOrientation);

      // Uzreiz uzbūvē lineālu
      updateAll();

      // ievades laukiem
      const scaleInputEl = document.getElementById("scale-maps");
      const unitEl = document.getElementById("unit");
      if (scaleInputEl) {
        scaleInputEl.addEventListener("change", () => {
          calculateDistanceDynamic(currentCmValue);
        });
      }
      if (unitEl) {
        unitEl.addEventListener("change", () => {
          calculateDistanceDynamic(currentCmValue);
        });
      }

      // Pele
      markerDraggable.addEventListener('mousedown', (e) => {
        e.preventDefault();
        isDragging = true;
        document.body.style.userSelect = 'none';
      });
      document.addEventListener('mouseup', () => {
        isDragging = false;
        document.body.style.userSelect = '';
      });
      document.addEventListener('mousemove', (e) => {
        if (!isDragging) return;
        e.preventDefault();
        handleDrag(e.clientX);
      });

      // Skārieni
      markerDraggable.addEventListener('touchstart', (e) => {
        e.preventDefault();
        isDragging = true;
        document.body.style.userSelect = 'none';
      }, { passive: false });

      document.addEventListener('touchend', () => {
        isDragging = false;
        document.body.style.userSelect = '';
      }, { passive: false });

      document.addEventListener('touchmove', (e) => {
        if (!isDragging) return;
        e.preventDefault();
        const touch = e.touches[0];
        handleDrag(touch.clientX);
      }, { passive: false });
    });
  </script>
</body>
</html>
